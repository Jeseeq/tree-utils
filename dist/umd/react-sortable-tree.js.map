{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-sortable-tree.js","webpack:///webpack/bootstrap 9ae6ba7af62d54afff81","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","undefined","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","treeIndex","children","expanded","nextIndex","childIndex","childCount","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$path","_ref3$lowerSiblingCou","selfInfo","callbackResult","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$path","_ref4$lowerSiblingCou","newChildren","map","child","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_extends","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","getNodeAtPath","_ref15","_ref15$ignoreCollapse","foundNodeInfo","_ref16","err","addNodeUnderParent","_ref17","_ref17$parentKey","parentKey","_ref17$ignoreCollapse","_ref17$expandParent","expandParent","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref18","key","parentNode","addNodeAtDepthAndIndex","_ref19","targetDepth","minimumTreeIndex","_ref19$isPseudoRoot","isLastChild","currentDepth","_ref19$path","n","extraNodeProps","nextNode","parentPath","insertIndex","pathFragment","insertNode","_ref20","depth","_ref20$getNodeKey","_ref20$ignoreCollapse","_ref20$expandParent","insertResult","getFlatDataFromTree","_ref21","_ref21$ignoreCollapse","flattened","_ref22","push","getTreeFromFlatData","_ref23","flatData","_ref23$getKey","getKey","_ref23$getParentKey","getParentKey","parentId","_ref23$rootKey","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","arguments","deepest","Math","max","find","_ref24","searchQuery","searchMethod","searchFocusOffset","_ref24$expandAllMatch","expandAllMatchPaths","_ref24$expandFocusMat","expandFocusMatchPaths","matchCount","_ref25","_ref25$isPseudoRoot","_ref25$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","Object","defineProperty","value","assign","target","source","prototype","hasOwnProperty"],"mappings":"CAAA,SAAAA,MAAAC;IACA,mBAAAC,WAAA,mBAAAC,SACAA,OAAAD,UAAAD,YACA,qBAAAG,iBAAAC,MACAD,WAAAH,WACA,mBAAAC,UACAA,QAAA,oBAAAD,YAEAD,KAAA,oBAAAC;EACCK,MAAA;IACD,OCAgB,SAAUC;QCN1B,SAAAC,oBAAAC;YAGA,IAAAC,iBAAAD,WACA,OAAAC,iBAAAD,UAAAP;YAGA,IAAAC,SAAAO,iBAAAD;gBACAP;gBACAS,IAAAF;gBACAG,SAAA;;YAUA,OANAL,QAAAE,UAAAI,KAAAV,OAAAD,SAAAC,eAAAD,SAAAM;YAGAL,OAAAS,UAAA,GAGAT,OAAAD;;QAvBA,IAAAQ;QAqCA,OATAF,oBAAAM,IAAAP,SAGAC,oBAAAO,IAAAL;QAGAF,oBAAAQ,IAAA,IAGAR,oBAAA;QDgBM,SAASL,QAAQD;QAEtB;QAyBA,SAASe,mBAAmBC;YAAO,IAAIC,MAAMC,QAAQF,MAAM;gBAAE,KAAK,IAAIG,IAAI,GAAGC,OAAOH,MAAMD,IAAIK,SAASF,IAAIH,IAAIK,QAAQF,KAAOC,KAAKD,KAAKH,IAAIG;gBAAM,OAAOC;;YAAe,OAAOH,MAAMK,KAAKN;;QE7E3L,SAASO,kCAATC;YASG,IARCC,cAQDD,KARCC,aACAC,OAODF,KAPCE,MACAC,eAMDH,KANCG,cACAC,aAKDJ,KALCI,YAKDC,YAAAL,KAJCM,aAIDC,WAAAF,4BAAAG,wBAAAR,KAHCS,yCAGDF,WAAAC,oDAAAE,uBAAAV,KAFCW,mCAEDJ,WAAAG,8CAAAE,oBAAAZ,KADCa,6BACDN,WAAAK,wCAEOE,WAAYD,uBAADE,OAAAxB,mBAAoBe,SAAMF;gBAAaF;gBAAMc,WAAWb;;YAGzE,IAAIA,iBAAiBF,aACjB;gBACIC;gBACAO;gBACAH,MAAMQ;;YAKd,KAAKZ,KAAKe,YAAaN,mBAAmBT,KAAKgB,cAAa,GACxD;gBAASC,WAAWhB,eAAe;;YAOvC,KAAK,IAFDiB,aAAejB,eAAe,GAC5BkB,aAAanB,KAAKe,SAASpB,QACxBF,IAAI,GAAGA,IAAI0B,YAAY1B,KAAK;gBACjC,IAAM2B,SAASvB;oBACXY;oBACAP;oBACAH;oBACAC,MAAMA,KAAKe,SAAStB;oBACpBQ,cAAciB;oBACdX,iDAAyBA,uBAAoBY,aAAa1B,IAAI;oBAC9DW,MAAMQ;;gBAGV,IAAIQ,OAAOpB,MACP,OAAOoB;gBAGXF,aAAaE,OAAOH;;YAIxB;gBAASA,WAAWC;;;QAGjB,SAASG,mBAATC;YAA8D,IAAhCtB,OAAgCsB,MAAhCtB,MAAgCuB,wBAAAD,MAA1Bb,mCAA0BJ,WAAAkB;YACjE,OAAO1B;gBACHK,YAAY;gBACZO;gBACAT;gBACAC,cAAc;gBACdF,cAAc;eACfkB,YAAY;;QAMnB,SAASO,gBAATC;YASG,IARCC,WAQDD,MARCC,UACAxB,aAODuB,MAPCvB,YACAO,kBAMDgB,MANChB,iBAMDkB,qBAAAF,MALCd,6BAKDN,WAAAsB,0CAJC3B,OAIDyB,MAJCzB,MACAC,eAGDwB,MAHCxB,cAGD2B,aAAAH,MAFCrB,aAEDC,WAAAuB,8BAAAC,wBAAAJ,MADClB,yCACDF,WAAAwB,oDAEOjB,WAAYD,uBAADE,OAAAxB,mBAAqBe,SAAMF;gBAAaF;gBAAMc,WAAWb;mBACpE6B,WAAYnB,eAAuF;gBAAtEX;gBAAMI,MAAMQ;gBAAUL;gBAAoBO,WAAWb;;YACxF,KAAKU,cAAc;gBACf,IAAMoB,iBAAiBL,SAASI;gBAGhC,IAAIC,oBAAmB,GACnB,QAAO;;YAKf,KAAK/B,KAAKe,YAAaf,KAAKgB,cAAa,KAAQP,oBAAoBE,cACjE,OAAOV;YAIX,IAAIiB,aAAejB,cACbkB,aAAanB,KAAKe,SAASpB;YACjC,IAA6B,qBAAlBK,KAAKe,UACZ,KAAK,IAAItB,IAAI,GAAGA,IAAI0B,YAAY1B,KAY5B,IAXAyB,aAAaM;gBACTE;gBACAxB;gBACAO;gBACAT,MAAMA,KAAKe,SAAStB;gBACpBQ,cAAciB,aAAa;gBAC3BX,iDAAyBA,uBAAoBY,aAAa1B,IAAI;gBAC9DW,MAAMQ;gBAINM,gBAAe,GACf,QAAO;YAKnB,OAAOA;;QAMX,SAASc,eAATC;YASG,IARCP,WAQDO,MARCP,UACAxB,aAOD+B,MAPC/B,YACAO,kBAMDwB,MANCxB,iBAMDyB,qBAAAD,MALCtB,6BAKDN,WAAA6B,0CAJClC,OAIDiC,MAJCjC,MACAC,eAGDgC,MAHChC,cAGDkC,aAAAF,MAFC7B,aAEDC,WAAA8B,8BAAAC,wBAAAH,MADC1B,yCACDF,WAAA+B,oDAEOxB,WAAYD,uBAADE,OAAAxB,mBAAqBe,SAAMF;gBAAaF;gBAAMc,WAAWb;mBACpE6B,WAAYnB,eAAuF;gBAAtEX;gBAAMI,MAAMQ;gBAAUL;gBAAoBO,WAAWb;;YAGxF,KAAKD,KAAKe,YAAaf,KAAKgB,cAAa,KAAQP,oBAAoBE,cACjE;gBACIG,WAAWb;gBACXD,MAAM0B,SAASI;;YAKvB,IAAIZ,aAAejB,cACbkB,aAAanB,KAAKe,SAASpB,QAC7B0C,cAAerC,KAAKe;YAkBxB,OAjB2B,qBAAhBsB,gBACPA,cAAcA,YAAYC,IAAI,SAACC,OAAO9C;gBAClC,IAAM+C,YAAYR;oBACdN;oBACAxB;oBACAO;oBACAT,MAAMuC;oBACNtC,cAAciB,aAAa;oBAC3BX,iDAAyBA,uBAAoBY,aAAa1B,IAAI;oBAC9DW,MAAMQ;;gBAIV,OAFAM,aAAasB,UAAU1B,WAEhB0B,UAAUxC;;gBAKrBA,MAAM0B,sBACCI;oBACH9B,mBACOA;wBACHe,UAAUsB;;;gBAGlBvB,WAAWI;;;QAWZ,SAASuB,oBAATC;YAA2C,IAAZC,WAAYD,MAAZC,UAC5BC,WAAW,SAAXA,SAAY5C;gBACd,OAAKA,KAAKe,YAAYf,KAAKgB,cAAa,KAAkC,qBAAlBhB,KAAKe,WAItD,IAAIf,KAAKe,SAAS8B,OAAO,SAACC,OAAOC;oBAAR,OAAyBD,QAAQF,SAASG;mBAAe,KAH9E;;YAMf,OAAOJ,SAASE,OAAO,SAACC,OAAOC;gBAAR,OAAwBD,QAAQF,SAASG;eAAc;;QAgB3E,SAASC,0BAATC;YAAiF,IAA5CN,WAA4CM,MAA5CN,UAAiB5C,cAA2BkD,MAAlCC,OAAoBhD,aAAc+C,MAAd/C;YACtE,KAAKyC,YAAYA,SAAShD,SAAS,GAC/B,OAAO;YAIX,IAAMyB,SAASvB;gBACXE;gBACAG;gBACAF;oBACIe,UAAU4B;oBACV3B,WAAU;;gBAEdf,eAAc;gBACdG;gBACAG;gBACAI,eAAc;;YAGlB,OAAIS,OAAOpB,OACAoB,SAGJ;;QAaJ,SAAS+B,KAATC;YAA0E,IAA1DT,WAA0DS,MAA1DT,UAAUzC,aAAgDkD,MAAhDlD,YAAYwB,WAAoC0B,MAApC1B,UAAoC2B,wBAAAD,MAA1B3C,mCAA0BJ,WAAAgD;YAC7E,IAAKV,cAAYA,SAAShD,SAAS,IAInC,OAAO6B;gBACHE;gBACAxB;gBACAO;gBACAE,eAAc;gBACdX;oBAAQe,UAAU4B;;gBAClB1C,eAAc;gBACdG;gBACAG;;;QAeD,SAAS+B,IAATgB;YAAyE,IAA1DX,WAA0DW,MAA1DX,UAAUzC,aAAgDoD,MAAhDpD,YAAYwB,WAAoC4B,MAApC5B,UAAoC6B,wBAAAD,MAA1B7C,mCAA0BJ,WAAAkD;YAC5E,QAAKZ,YAAYA,SAAShD,SAAS,SAI5BqC;gBACHN;gBACAxB;gBACAO;gBACAE,eAAc;gBACdX;oBAAQe,UAAU4B;;gBAClB1C,eAAc;gBACdG;gBACAG;eACDP,KAAKe;;QAWL,SAASyC,qBAATC;YAA6D,IAA7Bd,WAA6Bc,MAA7Bd,UAA6Be,iBAAAD,MAAnBzC,qBAAmBX,WAAAqD;YAChE,OAAOpB;gBACHK;gBACAjB,UAAU,SAAAiC;oBAAA,IAAG3D,OAAH2D,OAAG3D;oBAAH,OAAA4D,aAAoB5D;wBAAMgB;;;gBACpCd,YAAY,SAAA2D;oBAAA,IAAG/C,YAAH+C,OAAG/C;oBAAH,OAAmBA;;gBAC/BL,kBAAiB;;;QAelB,SAASqD,iBAATC;YAA2F,IAA/DpB,WAA+DoB,OAA/DpB,UAAUvC,OAAqD2D,OAArD3D,MAAM4D,UAA+CD,OAA/CC,SAAS9D,aAAsC6D,OAAtC7D,YAAsC+D,wBAAAF,OAA1BtD,mCAA0BJ,WAAA4D,gDACxFC,cAAc,eACdtB,WAAW,SAAXA,SAAWuB;gBAKX,IAAAC,sBAAAD,OAJFxD,6BAIEN,WAAA+D,4CAHFpE,OAGEmE,OAHFnE,MACAqE,mBAEEF,OAFFE,kBACAC,YACEH,OADFG;gBAEA,KAAK3D,gBAAgBT;oBAAaF;oBAAMc,WAAWuD;uBAAwBjE,KAAKkE,YAC5E,OAAOJ;gBAGX,IAAII,aAAalE,KAAKT,SAAS,GAE3B,OAA0B,qBAAZqE,UAAyBA;oBAAUhE;oBAAMc,WAAWuD;qBAAsBL;gBACrF,KAAKhE,KAAKe,UAEb,MAAM,IAAIwD,MAAM;gBAIpB,KAAK,IADDC,gBAAgBH,mBAAmB,GAC9B5E,IAAI,GAAGA,IAAIO,KAAKe,SAASpB,QAAQF,KAAK;oBAC3C,IAAM2B,UAASwB;wBACX5C,MAAkBA,KAAKe,SAAStB;wBAChC4E,kBAAkBG;wBAClBF,WAAkBA,YAAY;;oBAIlC,IAAIlD,YAAW8C,aACX,OAAI9C,UAGAwC,aACO5D;wBACHe,uCACOf,KAAKe,SAAS0D,MAAM,GAAGhF,OAC1B2B,WAFJ/B,mBAGOW,KAAKe,SAAS0D,MAAMhF,IAAI;yBAMvCmE,aACO5D;wBACHe,uCACOf,KAAKe,SAAS0D,MAAM,GAAGhF,KAD9BJ,mBAEOW,KAAKe,SAAS0D,MAAMhF,IAAI;;oBAKvC+E,iBAAiB,IAAInD;wBAAqBrB,MAAMA,KAAKe,SAAStB;wBAAIgB;;;gBAGtE,OAAOyD;eAIL9C,SAASwB;gBACX5C;oBAAQe,UAAU4B;;gBAClB0B,mBAAkB;gBAClBC,YAAW;gBACX3D,eAAc;;YAGlB,IAAIS,WAAW8C,aACX,MAAM,IAAIK,MAAM;YAGpB,OAAOnD,OAAOL;;QAaX,SAAS2D,iBAATC;YAAkF,IAAtDhC,WAAsDgC,OAAtDhC,UAAUvC,OAA4CuE,OAA5CvE,MAAMF,aAAsCyE,OAAtCzE,YAAsC0E,wBAAAD,OAA1BlE,mCAA0BJ,WAAAuE;YACrF,OAAOd;gBACHnB;gBACAvC;gBACAF;gBACAO;gBACAuD,SAAS;;;QAcV,SAASa,cAATC;YAA+E,IAAtDnC,WAAsDmC,OAAtDnC,UAAUvC,OAA4C0E,OAA5C1E,MAAMF,aAAsC4E,OAAtC5E,YAAsC6E,wBAAAD,OAA1BrE,mCAA0BJ,WAAA0E,gDAC9EC,gBAAgB;YAEpB;gBACIlB;oBACInB;oBACAvC;oBACAF;oBACAO;oBACAuD,SAAS,SAAAiB;wBAAyB,IAAtBjF,OAAsBiF,OAAtBjF,MAAMc,YAAgBmE,OAAhBnE;wBAEd,OADAkE;4BAAkBhF;4BAAMc;2BACjBd;;;cAGjB,OAAOkF;YAIT,OAAOF;;QAiBJ,SAASG,mBAATC;YAOJ,IANCzC,WAMDyC,OANCzC,UACAqB,UAKDoB,OALCpB,SAKDqB,mBAAAD,OAJCE,uBAIDjF,WAAAgF,mBAJa,OAIbA,kBAHCnF,aAGDkF,OAHClF,YAGDqF,wBAAAH,OAFC3E,mCAEDJ,WAAAkF,gDAAAC,sBAAAJ,OADCK,6BACDpF,WAAAmF;YACC,IAAkB,SAAdF,WACA;gBACI3C,uCAAgBA,mBAAiBqB;gBACjClD,YAAY6B,gBAAgBhD;;YAIpC,IAAI+F,oBAAoB,MACpBC,gBAAe,GACbC,kBAAkBtD;gBACpBK;gBACAzC;gBACAO;gBACAiB,UAAU,SAAAmE;oBAA+B,IAA5B7F,OAA4B6F,OAA5B7F,MAAMc,YAAsB+E,OAAtB/E,WAAWV,OAAWyF,OAAXzF,MACpB0F,MAAM1F,OAAOA,KAAKA,KAAKT,SAAS,KAAK;oBAE3C,IAAIgG,gBAAgBG,QAAQR,WACxB,OAAOtF;oBAEX2F,gBAAe;oBAEf,IAAMI,0BACC/F;oBAQP,IALIyF,iBACAM,WAAW/E,YAAW,KAIrB+E,WAAWhF,UAEZ,OADA2E,oBAAoB5E,YAAY;oBAChC8C,aACOmC;wBACHhF,YAAYiD;;oBAIpB,IAAmC,qBAAxB+B,WAAWhF,UAClB,MAAM,IAAIwD,MAAM;oBAIpB,KAAK,IADDC,gBAAgB1D,YAAY,GACvBrB,IAAI,GAAGA,IAAIsG,WAAWhF,SAASpB,QAAQF,KAC5C+E,iBAAiB,IAAInD;wBAAqBrB,MAAM+F,WAAWhF,SAAStB;wBAAIgB;;oBAK5E,OAFAiF,oBAAoBlB,eAEpBZ,aACOmC;wBACHhF,uCAAegF,WAAWhF,aAAUiD;;;;YAKhD,KAAK2B,cACD,MAAM,IAAIpB,MAAM;YAGpB;gBACI5B,UAAUiD;gBACV9E,WAAW4E;;;QAInB,SAASM,uBAATC;YAaG,IAZCC,cAYDD,OAZCC,aACAC,mBAWDF,OAXCE,kBACAnC,UAUDiC,OAVCjC,SACAvD,kBASDwF,OATCxF,iBACAgF,eAQDQ,OARCR,cAQDW,sBAAAH,OAPCtF,6BAODN,WAAA+F,4CANCC,cAMDJ,OANCI,aACArG,OAKDiG,OALCjG,MACAC,eAIDgG,OAJChG,cACAqG,eAGDL,OAHCK,cACApG,aAED+F,OAFC/F,YAEDqG,cAAAN,OADC7F,aACDC,WAAAkG,gCACO3F,WAAW,SAAA4F;gBAAA,OAAM7F,uBAAAE,OAAAxB,mBAChBe,SACHF;oBAAaF,MAAMwG;oBAAG1F,WAAWb;;;YAIrC,IAAIqG,iBAAiBJ,aACjB;gBACIlG;gBACAiB,WAAWhB,eAAe,IAAIoB;oBAAqBrB;oBAAMS;;;YAKjE,IAAIR,gBAAgBkG,mBAAmB,KAAME,gBAAgBrG,KAAKe,UAAW;gBACzE,IAA6B,qBAAlBf,KAAKe,UACZ,MAAM,IAAIwD,MAAM;gBAEhB,IAAMkC,iBAAiBhB;oBAAiBzE,WAAU;wBAC5C0F,yBACC1G,MAEAyG;oBACH1F,UAAUf,KAAKe,aAAYiD,UAAjBnD,OAAAxB,mBAA6BW,KAAKe,eAAaiD;;gBAG7D;oBACIhE,MAAM0G;oBACNzF,WAAWhB,eAAe;oBAC1ByF,mBAAmBzF,eAAe;oBAClC0G,YAAY/F,SAAS8F;;;YAKjC,IAAIJ,iBAAiBJ,cAAc,GAAG;gBAElC,KAAKlG,KAAKe,YACmB,qBAAlBf,KAAKe,YACXf,KAAKgB,cAAa,KAAQP,oBAAoBE,cAE/C;oBAASX;oBAAMiB,WAAWhB,eAAe;;gBAM7C,KAAK,IAHDiB,cAAoBjB,eAAe,GACnCyF,qBAAoB,MACpBkB,cAAoB,MACfnH,IAAI,GAAGA,IAAIO,KAAKe,SAASpB,QAAQF,KAAK;oBAC3C,IAAIyB,eAAciF,kBAAkB;wBAChCT,qBAAoBxE,aACpB0F,cAAcnH;wBACd;;oBAGJyB,eAAc,IAAIG;wBAAqBrB,MAAMA,KAAKe,SAAStB;wBAAIgB;;;gBAGnE,IAAoB,SAAhBmG,aAAsB;oBACtB,IAAI1F,cAAaiF,qBAAqBE,aAClC;wBAASrG;wBAAMiB,WAAWC;;oBAG9BwE,qBAAoBxE,aACpB0F,cAAc5G,KAAKe,SAASpB;;gBAGhC,IAAM+G,0BACC1G;oBACHe,uCACOf,KAAKe,SAAS0D,MAAM,GAAGmC,iBAC1B5C,WAFJ3E,mBAGOW,KAAKe,SAAS0D,MAAMmC;;gBAI/B;oBACI5G,MAAM0G;oBACNzF,WAAWC;oBACXwE;oBACAiB,YAAY/F,SAAS8F;;;YAK7B,KAAK1G,KAAKe,YACmB,qBAAlBf,KAAKe,YACXf,KAAKgB,cAAa,KAAQP,oBAAoBE,cAE/C;gBAASX;gBAAMiB,WAAWhB,eAAe;;YAI7C,IAAIyF,oBAAoB,MACpBmB,eAAoB,MACpB3F,aAAoBjB,eAAe,GACnCoC,cAAoBrC,KAAKe;YACF,qBAAhBsB,gBACPA,cAAcA,YAAYC,IAAI,SAACC,OAAO9C;gBAClC,IAA0B,SAAtBiG,mBACA,OAAOnD;gBAGX,IAAMC,YAAYwD;oBACdE;oBACAC;oBACAnC;oBACAvD;oBACAgF;oBACAY,aAAaA,eAAe5G,MAAM4C,YAAY1C,SAAS;oBACvDK,MAAMuC;oBACNtC,cAAciB;oBACdoF,cAAcA,eAAe;oBAC7BpG;oBACAE;;gBASJ,OANI,uBAAuBoC,cACpBkD,oBAAgDlD,UAAhDkD;gBAA+BmB,eAAiBrE,UAA7BmE,aAG1BzF,aAAasB,UAAUvB,WAEhBuB,UAAUxC;;YAIzB,IAAM0G,wBAAgB1G;gBAAMe,UAAUsB;gBAChCjB;gBACFpB,MAAM0G;gBACNzF,WAAWC;;YAQf,OAL0B,SAAtBwE,sBACAtE,OAAOsE,oBAAoBA;YAC3BtE,OAAOuF,gBAAP9F,OAAAxB,mBAAgCuB,SAAS8F,YAAzCrH,mBAAuDwH;YAGpDzF;;QAoBJ,SAAS0F,WAATC;YAQJ,IAPCpE,WAODoE,OAPCpE,UACOuD,cAMRa,OANCC,OACAb,mBAKDY,OALCZ,kBACAnC,UAID+C,OAJC/C,SAIDiD,oBAAAF,OAHC7G,yBAGDG,WAAA4G,oBAHc,gBAGdA,mBAAAC,wBAAAH,OAFCtG,mCAEDJ,WAAA6G,gDAAAC,sBAAAJ,OADCtB,6BACDpF,WAAA8G;YACC,KAAKxE,YAA4B,MAAhBuD,aACb;gBACIvD,YAAYqB;gBACZlD,WAAW;gBACXV,QAAYF;oBAAaF,MAAMgE;oBAASlD,WAAW;;;YAI3D,IAAMsG,eAAepB;gBACjBE;gBACAC;gBACAnC;gBACAvD;gBACAgF;gBACAvF;gBACAS,eAAc;gBACd0F,cAAa;gBACbrG;oBAAQe,UAAU4B;;gBAClB1C,eAAc;gBACdqG,eAAc;;YAGlB,MAAM,uBAAuBc,eACzB,MAAM,IAAI7C,MAAM;YAGpB,IAAMzD,YAAYsG,aAAa1B;YAC/B;gBACI/C,UAAUyE,aAAapH,KAAKe;gBAC5BD;gBACAV,mCAAegH,aAAaT,eAAYzG;oBAAaF,MAAMgE;oBAASlD;;;;QAiBrE,SAASuG,oBAATC;YAA+E,IAAhD3E,WAAgD2E,OAAhD3E,UAAUzC,aAAsCoH,OAAtCpH,YAAsCqH,wBAAAD,OAA1B7G,mCAA0BJ,WAAAkH;YAClF,KAAK5E,YAAYA,SAAShD,SAAS,GAC/B;YAGJ,IAAM6H;YAUN,OATArE;gBACIR;gBACAzC;gBACAO;gBACAiB,UAAU,SAAA+F;oBAAmD,IAAhDzH,OAAgDyH,OAAhDzH,MAAMO,qBAA0CkH,OAA1ClH,oBAAoBH,OAAsBqH,OAAtBrH,MAAMU,YAAgB2G,OAAhB3G;oBACzC0G,UAAUE;wBAAO1H;wBAAMO;wBAAoBH;wBAAMU;;;gBAIlD0G;;QAcJ,SAASG,oBAATC;YAKJ,IAJCC,WAIDD,OAJCC,UAIDC,gBAAAF,OAHCG,iBAGD1H,WAAAyH,gBAHW,SAAA9H;gBAAA,OAAQA,KAAKjB;gBAGxB+I,eAAAE,sBAAAJ,OAFCK,6BAED5H,WAAA2H,sBAFiB,SAAAhI;gBAAA,OAAQA,KAAKkI;gBAE9BF,qBAAAG,iBAAAP,OADCQ,mBACD/H,WAAA8H,iBADW,MACXA;YACC,KAAKN,UACD;YAGJ,IAAMQ;YAWN,IAVAR,SAASS,QAAQ,SAAC/F;gBACd,IAAM+C,YAAY2C,aAAa1F;gBAE3B+C,aAAa+C,oBACbA,kBAAkB/C,WAAWoC,KAAKnF,SAElC8F,kBAAkB/C,eAAe/C;kBAInC6F,WAAWC,oBACb;YAGJ,IAAME,OAAO,SAAPA,KAAQC;gBACV,IAAMlD,YAAYyC,OAAOS;gBACzB,OAAIlD,aAAa+C,oBACbzE,aACO4E;oBACHzH,UAAUsH,kBAAkB/C,WAAWhD,IAAI,SAAAC;wBAAA,OAASgG,KAAKhG;;qBAIjEqB,aAAY4E;;YAGhB,OAAOH,kBAAkBD,SAAS9F,IAAI,SAAAC;gBAAA,OAASgG,KAAKhG;;;QAWjD,SAASkG,aAAaC,OAAOC;YAChC,SAASD,MAAM3H,YAAsC,qBAAnB2H,MAAM3H,YACpC2H,MAAM3H,SAAS6H,KAAK,SAAArG;gBAAA,OAAUA,UAAUoG,WAAWF,aAAalG,OAAOoG;;;QAWxE,SAASE,SAAS7I;YAAiB,IAAXgH,QAAW8B,UAAAnJ,SAAA,KAAAU,WAAAyI,UAAA,KAAAA,UAAA,KAAH;YACnC,OAAK9I,KAAKe,WAImB,qBAAlBf,KAAKe,WACLiG,QAAQ,IAGZhH,KAAKe,SAAS8B,OACjB,SAACkG,SAASxG;gBAAV,OAAoByG,KAAKC,IAAIF,SAASF,SAAStG,OAAOyE,QAAQ;eAC9DA,SATOA;;QA8BR,SAASkC,KAATC;YAQJ,IAPCjJ,aAODiJ,OAPCjJ,YACAyC,WAMDwG,OANCxG,UACAyG,cAKDD,OALCC,aACAC,eAIDF,OAJCE,cACAC,oBAGDH,OAHCG,mBAGDC,wBAAAJ,OAFCK,2CAEDnJ,WAAAkJ,gDAAAE,wBAAAN,OADCO,+CACDrJ,WAAAoJ,gDACKE,aAAa,GACXpB,OAAO,SAAPA,KAAOqB;gBAKP,IAAAC,sBAAAD,OAJFjJ,6BAIEN,WAAAwJ,4CAHF7J,OAGE4J,OAHF5J,MACAC,eAEE2J,OAFF3J,cAEE6J,cAAAF,OADFxJ,aACEC,WAAAyJ,gCACEC,cACAC,eAAc,GACdC,iBAAgB,GAEdrJ,WAAWD,uBAAAE,OAAAxB,mBACVe,SACHF;oBAAaF;oBAAMc,WAAWb;uBAE5BiK,YAAYvJ,eAAe;oBAC7BP,MAAMQ;oBACNE,WAAWb;mBAITkK,cAAcnK,KAAKe,YACI,qBAAlBf,KAAKe,YACZf,KAAKe,SAASpB,SAAS;iBAGtBgB,gBAAgB0I,0BAAkBa;oBAAWlK;oBAAMoJ;wBAChDO,eAAeL,sBACfW,iBAAgB,IAKpBN;gBAMAK,eAAc;gBAGlB,IAAI9I,aAAajB,cACX+D,uBAAehE;gBAyDrB,OAxDImK,gBAEAnG,QAAQjD,WAAWiD,QAAQjD,SAASuB,IAAI,SAACC;oBACrC,IAAMC,YAAY+F;wBACdvI,MAAMuC;wBACNtC,cAAciB,aAAa;wBAC3Bd,MAAMQ;;oBA6BV,OArBI4B,UAAUxC,KAAKgB,WACfE,aAAasB,UAAU1B,YAEvBI,cAAc;qBAGdsB,UAAUuH,QAAQpK,SAAS,KAAK6C,UAAUyH,mBAC1CF,uCAAeA,UAAf1K,mBAA2BmD,UAAUuH;oBACjCvH,UAAUyH,kBACVA,iBAAgB,KAKfT,uBAAuBhH,UAAUuH,QAAQpK,SAAS,MACjD6J,uBAAuBE,0BAA0BlH,UAAUyH,mBAE7DjG,QAAQhD,YAAW;oBAIpBwB,UAAUxC;qBAKpBW,gBAAiBqD,QAAQhD,aAC1B+I,UAAUA,QAAQzH,IAAI,SAAA8H;oBAAA,OAAAxG,aACfwG;wBACHtJ,WAAW;;qBAMfkJ,gBACAD,yBACSG;oBAAWlK,MAAMgE;qBAD1BnD,OAAAxB,mBAEO0K;oBAKP/J,MAAM+J,QAAQpK,SAAS,IAAIqE,UAAUhE;oBACrC+J;oBACAE;oBACAnJ,WAAWI;;eAIbE,SAASmH;gBACXvI;oBAAQe,UAAU4B;;gBAClBhC,eAAc;gBACdV,eAAc;;YAGlB;gBACI8J,SAAS3I,OAAO2I;gBAChBpH,UAAUvB,OAAOpB,KAAKe;;;QFt7B7BsJ,OAAOC,eAAehM,SAAS;YAC3BiM,QAAO;;QAGX,IAAI3G,WAAWyG,OAAOG,UAAU,SAAUC;YAAU,KAAK,IAAIhL,IAAI,GAAGA,IAAIqJ,UAAUnJ,QAAQF,KAAK;gBAAE,IAAIiL,SAAS5B,UAAUrJ;gBAAI,KAAK,IAAIqG,OAAO4E,QAAcL,OAAOM,UAAUC,eAAe3L,KAAKyL,QAAQ5E,SAAQ2E,OAAO3E,OAAO4E,OAAO5E;;YAAY,OAAO2E;;QAEvPnM,QEPe+C,yCFQf/C,QE0HemE;QFzHfnE,QEkJe0E,uDFjJf1E,QEqLe6E;QFpLf7E,QEgNegE,WF/MfhE,QEwOekF,6CFvOflF,QE2PewF;QF1PfxF,QE8UeoG,qCF7UfpG,QEiWeuG;QFhWfvG,QEmYe6G,yCFlYf7G,QEunBewI;QFtnBfxI,QE8qBe+I,2CF7qBf/I,QE0sBeqJ;QFzsBfrJ,QEyvBemK,6BFxvBfnK,QEqwBeuK,qBFpwBfvK,QEoyBe4K","file":"react-sortable-tree.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSortableTree\"] = factory();\n\telse\n\t\troot[\"ReactSortableTree\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSortableTree\"] = factory();\n\telse\n\t\troot[\"ReactSortableTree\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports.getDescendantCount = getDescendantCount;\n\texports.getVisibleNodeCount = getVisibleNodeCount;\n\texports.getVisibleNodeInfoAtIndex = getVisibleNodeInfoAtIndex;\n\texports.walk = walk;\n\texports.map = map;\n\texports.toggleExpandedForAll = toggleExpandedForAll;\n\texports.changeNodeAtPath = changeNodeAtPath;\n\texports.removeNodeAtPath = removeNodeAtPath;\n\texports.getNodeAtPath = getNodeAtPath;\n\texports.addNodeUnderParent = addNodeUnderParent;\n\texports.insertNode = insertNode;\n\texports.getFlatDataFromTree = getFlatDataFromTree;\n\texports.getTreeFromFlatData = getTreeFromFlatData;\n\texports.isDescendant = isDescendant;\n\texports.getDepth = getDepth;\n\texports.find = find;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/**\n\t * Performs a depth-first traversal over all of the node descendants,\n\t * incrementing currentIndex by 1 for each\n\t */\n\tfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n\t    var targetIndex = _ref.targetIndex,\n\t        node = _ref.node,\n\t        currentIndex = _ref.currentIndex,\n\t        getNodeKey = _ref.getNodeKey,\n\t        _ref$path = _ref.path,\n\t        path = _ref$path === undefined ? [] : _ref$path,\n\t        _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n\t        lowerSiblingCounts = _ref$lowerSiblingCoun === undefined ? [] : _ref$lowerSiblingCoun,\n\t        _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n\t        ignoreCollapsed = _ref$ignoreCollapsed === undefined ? true : _ref$ignoreCollapsed,\n\t        _ref$isPseudoRoot = _ref.isPseudoRoot,\n\t        isPseudoRoot = _ref$isPseudoRoot === undefined ? false : _ref$isPseudoRoot;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t\n\t    // Return target node when found\n\t    if (currentIndex === targetIndex) {\n\t        return {\n\t            node: node,\n\t            lowerSiblingCounts: lowerSiblingCounts,\n\t            path: selfPath\n\t        };\n\t    }\n\t\n\t    // Add one and continue for nodes with no children or hidden children\n\t    if (!node.children || ignoreCollapsed && node.expanded !== true) {\n\t        return { nextIndex: currentIndex + 1 };\n\t    }\n\t\n\t    // Iterate over each child and their descendants and return the\n\t    // target node if childIndex reaches the targetIndex\n\t    var childIndex = currentIndex + 1;\n\t    var childCount = node.children.length;\n\t    for (var i = 0; i < childCount; i++) {\n\t        var result = getNodeDataAtTreeIndexOrNextIndex({\n\t            ignoreCollapsed: ignoreCollapsed,\n\t            getNodeKey: getNodeKey,\n\t            targetIndex: targetIndex,\n\t            node: node.children[i],\n\t            currentIndex: childIndex,\n\t            lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t            path: selfPath\n\t        });\n\t\n\t        if (result.node) {\n\t            return result;\n\t        }\n\t\n\t        childIndex = result.nextIndex;\n\t    }\n\t\n\t    // If the target node is not found, return the farthest traversed index\n\t    return { nextIndex: childIndex };\n\t}\n\t\n\tfunction getDescendantCount(_ref2) {\n\t    var node = _ref2.node,\n\t        _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n\t        ignoreCollapsed = _ref2$ignoreCollapsed === undefined ? true : _ref2$ignoreCollapsed;\n\t\n\t    return getNodeDataAtTreeIndexOrNextIndex({\n\t        getNodeKey: function getNodeKey() {},\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        node: node,\n\t        currentIndex: 0,\n\t        targetIndex: -1\n\t    }).nextIndex - 1;\n\t}\n\t\n\t/**\n\t * Walk all descendants of the given node\n\t */\n\tfunction walkDescendants(_ref3) {\n\t    var callback = _ref3.callback,\n\t        getNodeKey = _ref3.getNodeKey,\n\t        ignoreCollapsed = _ref3.ignoreCollapsed,\n\t        _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n\t        isPseudoRoot = _ref3$isPseudoRoot === undefined ? false : _ref3$isPseudoRoot,\n\t        node = _ref3.node,\n\t        currentIndex = _ref3.currentIndex,\n\t        _ref3$path = _ref3.path,\n\t        path = _ref3$path === undefined ? [] : _ref3$path,\n\t        _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n\t        lowerSiblingCounts = _ref3$lowerSiblingCou === undefined ? [] : _ref3$lowerSiblingCou;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t    var selfInfo = !isPseudoRoot ? { node: node, path: selfPath, lowerSiblingCounts: lowerSiblingCounts, treeIndex: currentIndex } : null;\n\t    if (!isPseudoRoot) {\n\t        var callbackResult = callback(selfInfo);\n\t\n\t        // Cut walk short if the callback returned false\n\t        if (callbackResult === false) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    // Return self on nodes with no children or hidden children\n\t    if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return currentIndex;\n\t    }\n\t\n\t    // Get all descendants\n\t    var childIndex = currentIndex;\n\t    var childCount = node.children.length;\n\t    if (typeof node.children !== 'function') {\n\t        for (var i = 0; i < childCount; i++) {\n\t            childIndex = walkDescendants({\n\t                callback: callback,\n\t                getNodeKey: getNodeKey,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                node: node.children[i],\n\t                currentIndex: childIndex + 1,\n\t                lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t                path: selfPath\n\t            });\n\t\n\t            // Cut walk short if the callback returned false\n\t            if (childIndex === false) {\n\t                return false;\n\t            }\n\t        }\n\t    }\n\t\n\t    return childIndex;\n\t}\n\t\n\t/**\n\t * Perform a change on the given node and all its descendants\n\t */\n\tfunction mapDescendants(_ref4) {\n\t    var callback = _ref4.callback,\n\t        getNodeKey = _ref4.getNodeKey,\n\t        ignoreCollapsed = _ref4.ignoreCollapsed,\n\t        _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n\t        isPseudoRoot = _ref4$isPseudoRoot === undefined ? false : _ref4$isPseudoRoot,\n\t        node = _ref4.node,\n\t        currentIndex = _ref4.currentIndex,\n\t        _ref4$path = _ref4.path,\n\t        path = _ref4$path === undefined ? [] : _ref4$path,\n\t        _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n\t        lowerSiblingCounts = _ref4$lowerSiblingCou === undefined ? [] : _ref4$lowerSiblingCou;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t    var selfInfo = !isPseudoRoot ? { node: node, path: selfPath, lowerSiblingCounts: lowerSiblingCounts, treeIndex: currentIndex } : null;\n\t\n\t    // Return self on nodes with no children or hidden children\n\t    if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return {\n\t            treeIndex: currentIndex,\n\t            node: callback(selfInfo)\n\t        };\n\t    }\n\t\n\t    // Get all descendants\n\t    var childIndex = currentIndex;\n\t    var childCount = node.children.length;\n\t    var newChildren = node.children;\n\t    if (typeof newChildren !== 'function') {\n\t        newChildren = newChildren.map(function (child, i) {\n\t            var mapResult = mapDescendants({\n\t                callback: callback,\n\t                getNodeKey: getNodeKey,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                node: child,\n\t                currentIndex: childIndex + 1,\n\t                lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t                path: selfPath\n\t            });\n\t            childIndex = mapResult.treeIndex;\n\t\n\t            return mapResult.node;\n\t        });\n\t    }\n\t\n\t    return {\n\t        node: callback(_extends({}, selfInfo, {\n\t            node: _extends({}, node, {\n\t                children: newChildren\n\t            })\n\t        })),\n\t        treeIndex: childIndex\n\t    };\n\t}\n\t\n\t/**\n\t * Count all the visible (expanded) descendants in the tree data.\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t *\n\t * @return {number} count\n\t */\n\tfunction getVisibleNodeCount(_ref5) {\n\t    var treeData = _ref5.treeData;\n\t\n\t    var traverse = function traverse(node) {\n\t        if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n\t            return 1;\n\t        }\n\t\n\t        return 1 + node.children.reduce(function (total, currentNode) {\n\t            return total + traverse(currentNode);\n\t        }, 0);\n\t    };\n\t\n\t    return treeData.reduce(function (total, currentNode) {\n\t        return total + traverse(currentNode);\n\t    }, 0);\n\t}\n\t\n\t/**\n\t * Get the <targetIndex>th visible node in the tree data.\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!number} targetIndex - The index of the node to search for\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t *\n\t * @return {{\n\t *      node: Object,\n\t *      path: []string|[]number,\n\t *      lowerSiblingCounts: []number\n\t *  }|null} node - The node at targetIndex, or null if not found\n\t */\n\tfunction getVisibleNodeInfoAtIndex(_ref6) {\n\t    var treeData = _ref6.treeData,\n\t        targetIndex = _ref6.index,\n\t        getNodeKey = _ref6.getNodeKey;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return null;\n\t    }\n\t\n\t    // Call the tree traversal with a pseudo-root node\n\t    var result = getNodeDataAtTreeIndexOrNextIndex({\n\t        targetIndex: targetIndex,\n\t        getNodeKey: getNodeKey,\n\t        node: {\n\t            children: treeData,\n\t            expanded: true\n\t        },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: [],\n\t        isPseudoRoot: true\n\t    });\n\t\n\t    if (result.node) {\n\t        return result;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t * Walk descendants depth-first and call a callback on each\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {function} callback - Function to call on each node\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return void\n\t */\n\tfunction walk(_ref7) {\n\t    var treeData = _ref7.treeData,\n\t        getNodeKey = _ref7.getNodeKey,\n\t        callback = _ref7.callback,\n\t        _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n\t        ignoreCollapsed = _ref7$ignoreCollapsed === undefined ? true : _ref7$ignoreCollapsed;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return;\n\t    }\n\t\n\t    return walkDescendants({\n\t        callback: callback,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        isPseudoRoot: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: []\n\t    });\n\t}\n\t\n\t/**\n\t * Perform a depth-first transversal of the descendants and\n\t *  make a change to every node in the tree\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {function} callback - Function to call on each node\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object[]} changedTreeData - The changed tree data\n\t */\n\tfunction map(_ref8) {\n\t    var treeData = _ref8.treeData,\n\t        getNodeKey = _ref8.getNodeKey,\n\t        callback = _ref8.callback,\n\t        _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n\t        ignoreCollapsed = _ref8$ignoreCollapsed === undefined ? true : _ref8$ignoreCollapsed;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return [];\n\t    }\n\t\n\t    return mapDescendants({\n\t        callback: callback,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        isPseudoRoot: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: []\n\t    }).node.children;\n\t}\n\t\n\t/**\n\t * Expand or close every node in the tree\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {?boolean} expanded - Whether the node is expanded or not\n\t *\n\t * @return {Object[]} changedTreeData - The changed tree data\n\t */\n\tfunction toggleExpandedForAll(_ref9) {\n\t    var treeData = _ref9.treeData,\n\t        _ref9$expanded = _ref9.expanded,\n\t        expanded = _ref9$expanded === undefined ? true : _ref9$expanded;\n\t\n\t    return map({\n\t        treeData: treeData,\n\t        callback: function callback(_ref10) {\n\t            var node = _ref10.node;\n\t            return _extends({}, node, { expanded: expanded });\n\t        },\n\t        getNodeKey: function getNodeKey(_ref11) {\n\t            var treeIndex = _ref11.treeIndex;\n\t            return treeIndex;\n\t        },\n\t        ignoreCollapsed: false\n\t    });\n\t}\n\t\n\t/**\n\t * Replaces node at path with object, or callback-defined object\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n\t * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object[]} changedTreeData - The changed tree data\n\t */\n\tfunction changeNodeAtPath(_ref12) {\n\t    var treeData = _ref12.treeData,\n\t        path = _ref12.path,\n\t        newNode = _ref12.newNode,\n\t        getNodeKey = _ref12.getNodeKey,\n\t        _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n\t        ignoreCollapsed = _ref12$ignoreCollapse === undefined ? true : _ref12$ignoreCollapse;\n\t\n\t    var RESULT_MISS = 'RESULT_MISS';\n\t    var traverse = function traverse(_ref13) {\n\t        var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n\t            isPseudoRoot = _ref13$isPseudoRoot === undefined ? false : _ref13$isPseudoRoot,\n\t            node = _ref13.node,\n\t            currentTreeIndex = _ref13.currentTreeIndex,\n\t            pathIndex = _ref13.pathIndex;\n\t\n\t        if (!isPseudoRoot && getNodeKey({ node: node, treeIndex: currentTreeIndex }) !== path[pathIndex]) {\n\t            return RESULT_MISS;\n\t        }\n\t\n\t        if (pathIndex >= path.length - 1) {\n\t            // If this is the final location in the path, return its changed form\n\t            return typeof newNode === 'function' ? newNode({ node: node, treeIndex: currentTreeIndex }) : newNode;\n\t        } else if (!node.children) {\n\t            // If this node is part of the path, but has no children, return the unchanged node\n\t            throw new Error('Path referenced children of node with no children.');\n\t        }\n\t\n\t        var nextTreeIndex = currentTreeIndex + 1;\n\t        for (var i = 0; i < node.children.length; i++) {\n\t            var _result = traverse({\n\t                node: node.children[i],\n\t                currentTreeIndex: nextTreeIndex,\n\t                pathIndex: pathIndex + 1\n\t            });\n\t\n\t            // If the result went down the correct path\n\t            if (_result !== RESULT_MISS) {\n\t                if (_result) {\n\t                    // If the result was truthy (in this case, an object),\n\t                    //  pass it to the next level of recursion up\n\t                    return _extends({}, node, {\n\t                        children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))\n\t                    });\n\t                }\n\t                // If the result was falsy (returned from the newNode function), then\n\t                //  delete the node from the array.\n\t                return _extends({}, node, {\n\t                    children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))\n\t                });\n\t            }\n\t\n\t            nextTreeIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed: ignoreCollapsed });\n\t        }\n\t\n\t        return RESULT_MISS;\n\t    };\n\t\n\t    // Use a pseudo-root node in the beginning traversal\n\t    var result = traverse({\n\t        node: { children: treeData },\n\t        currentTreeIndex: -1,\n\t        pathIndex: -1,\n\t        isPseudoRoot: true\n\t    });\n\t\n\t    if (result === RESULT_MISS) {\n\t        throw new Error('No node found at the given path.');\n\t    }\n\t\n\t    return result.children;\n\t}\n\t\n\t/**\n\t * Removes the node at the specified path and returns the resulting treeData.\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object[]} changedTreeData - The tree data with the node removed\n\t */\n\tfunction removeNodeAtPath(_ref14) {\n\t    var treeData = _ref14.treeData,\n\t        path = _ref14.path,\n\t        getNodeKey = _ref14.getNodeKey,\n\t        _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n\t        ignoreCollapsed = _ref14$ignoreCollapse === undefined ? true : _ref14$ignoreCollapse;\n\t\n\t    return changeNodeAtPath({\n\t        treeData: treeData,\n\t        path: path,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        newNode: null });\n\t}\n\t\n\t/**\n\t * Gets the node at the specified path\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n\t */\n\tfunction getNodeAtPath(_ref15) {\n\t    var treeData = _ref15.treeData,\n\t        path = _ref15.path,\n\t        getNodeKey = _ref15.getNodeKey,\n\t        _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n\t        ignoreCollapsed = _ref15$ignoreCollapse === undefined ? true : _ref15$ignoreCollapse;\n\t\n\t    var foundNodeInfo = null;\n\t\n\t    try {\n\t        changeNodeAtPath({\n\t            treeData: treeData,\n\t            path: path,\n\t            getNodeKey: getNodeKey,\n\t            ignoreCollapsed: ignoreCollapsed,\n\t            newNode: function newNode(_ref16) {\n\t                var node = _ref16.node,\n\t                    treeIndex = _ref16.treeIndex;\n\t\n\t                foundNodeInfo = { node: node, treeIndex: treeIndex };\n\t                return node;\n\t            }\n\t        });\n\t    } catch (err) {\n\t        // Ignore the error -- the null return will be explanation enough\n\t    }\n\t\n\t    return foundNodeInfo;\n\t}\n\t\n\t/**\n\t * Adds the node to the specified parent and returns the resulting treeData.\n\t *\n\t * @param {!Object[]} treeData\n\t * @param {!Object} newNode - The node to insert\n\t * @param {number|string} parentKey - The key of the to-be parentNode of the node\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n\t *\n\t * @return {Object} result\n\t * @return {Object[]} result.treeData - The updated tree data\n\t * @return {number} result.treeIndex - The tree index at which the node was inserted\n\t */\n\tfunction addNodeUnderParent(_ref17) {\n\t    var treeData = _ref17.treeData,\n\t        newNode = _ref17.newNode,\n\t        _ref17$parentKey = _ref17.parentKey,\n\t        parentKey = _ref17$parentKey === undefined ? null : _ref17$parentKey,\n\t        getNodeKey = _ref17.getNodeKey,\n\t        _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n\t        ignoreCollapsed = _ref17$ignoreCollapse === undefined ? true : _ref17$ignoreCollapse,\n\t        _ref17$expandParent = _ref17.expandParent,\n\t        expandParent = _ref17$expandParent === undefined ? false : _ref17$expandParent;\n\t\n\t    if (parentKey === null) {\n\t        return {\n\t            treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),\n\t            treeIndex: (treeData || []).length\n\t        };\n\t    }\n\t\n\t    var insertedTreeIndex = null;\n\t    var hasBeenAdded = false;\n\t    var changedTreeData = map({\n\t        treeData: treeData,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        callback: function callback(_ref18) {\n\t            var node = _ref18.node,\n\t                treeIndex = _ref18.treeIndex,\n\t                path = _ref18.path;\n\t\n\t            var key = path ? path[path.length - 1] : null;\n\t            // Return nodes that are not the parent as-is\n\t            if (hasBeenAdded || key !== parentKey) {\n\t                return node;\n\t            }\n\t            hasBeenAdded = true;\n\t\n\t            var parentNode = _extends({}, node);\n\t\n\t            if (expandParent) {\n\t                parentNode.expanded = true;\n\t            }\n\t\n\t            // If no children exist yet, just add the single newNode\n\t            if (!parentNode.children) {\n\t                insertedTreeIndex = treeIndex + 1;\n\t                return _extends({}, parentNode, {\n\t                    children: [newNode]\n\t                });\n\t            }\n\t\n\t            if (typeof parentNode.children === 'function') {\n\t                throw new Error('Cannot add to children defined by a function');\n\t            }\n\t\n\t            var nextTreeIndex = treeIndex + 1;\n\t            for (var i = 0; i < parentNode.children.length; i++) {\n\t                nextTreeIndex += 1 + getDescendantCount({ node: parentNode.children[i], ignoreCollapsed: ignoreCollapsed });\n\t            }\n\t\n\t            insertedTreeIndex = nextTreeIndex;\n\t\n\t            return _extends({}, parentNode, {\n\t                children: [].concat(_toConsumableArray(parentNode.children), [newNode])\n\t            });\n\t        }\n\t    });\n\t\n\t    if (!hasBeenAdded) {\n\t        throw new Error('No node found with the given key.');\n\t    }\n\t\n\t    return {\n\t        treeData: changedTreeData,\n\t        treeIndex: insertedTreeIndex\n\t    };\n\t}\n\t\n\tfunction addNodeAtDepthAndIndex(_ref19) {\n\t    var targetDepth = _ref19.targetDepth,\n\t        minimumTreeIndex = _ref19.minimumTreeIndex,\n\t        newNode = _ref19.newNode,\n\t        ignoreCollapsed = _ref19.ignoreCollapsed,\n\t        expandParent = _ref19.expandParent,\n\t        _ref19$isPseudoRoot = _ref19.isPseudoRoot,\n\t        isPseudoRoot = _ref19$isPseudoRoot === undefined ? false : _ref19$isPseudoRoot,\n\t        isLastChild = _ref19.isLastChild,\n\t        node = _ref19.node,\n\t        currentIndex = _ref19.currentIndex,\n\t        currentDepth = _ref19.currentDepth,\n\t        getNodeKey = _ref19.getNodeKey,\n\t        _ref19$path = _ref19.path,\n\t        path = _ref19$path === undefined ? [] : _ref19$path;\n\t\n\t    var selfPath = function selfPath(n) {\n\t        return isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: n, treeIndex: currentIndex })]);\n\t    };\n\t\n\t    // If the potential parent node is at the targetDepth, it isn't eligible\n\t    if (currentDepth === targetDepth) {\n\t        return {\n\t            node: node,\n\t            nextIndex: currentIndex + 1 + getDescendantCount({ node: node, ignoreCollapsed: ignoreCollapsed })\n\t        };\n\t    }\n\t\n\t    // If the current position is the only possible place to add, add it\n\t    if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !node.children) {\n\t        if (typeof node.children === 'function') {\n\t            throw new Error('Cannot add to children defined by a function');\n\t        } else {\n\t            var extraNodeProps = expandParent ? { expanded: true } : {};\n\t            var _nextNode = _extends({}, node, extraNodeProps, {\n\t                children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n\t            });\n\t\n\t            return {\n\t                node: _nextNode,\n\t                nextIndex: currentIndex + 2,\n\t                insertedTreeIndex: currentIndex + 1,\n\t                parentPath: selfPath(_nextNode)\n\t            };\n\t        }\n\t    }\n\t\n\t    if (currentDepth === targetDepth - 1) {\n\t        // Skip over nodes with no children or hidden children\n\t        if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t            return { node: node, nextIndex: currentIndex + 1 };\n\t        }\n\t\n\t        var _childIndex = currentIndex + 1;\n\t        var _insertedTreeIndex = null;\n\t        var insertIndex = null;\n\t        for (var i = 0; i < node.children.length; i++) {\n\t            if (_childIndex >= minimumTreeIndex) {\n\t                _insertedTreeIndex = _childIndex;\n\t                insertIndex = i;\n\t                break;\n\t            }\n\t\n\t            _childIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed: ignoreCollapsed });\n\t        }\n\t\n\t        if (insertIndex === null) {\n\t            if (_childIndex < minimumTreeIndex && !isLastChild) {\n\t                return { node: node, nextIndex: _childIndex };\n\t            }\n\t\n\t            _insertedTreeIndex = _childIndex;\n\t            insertIndex = node.children.length;\n\t        }\n\t\n\t        var _nextNode2 = _extends({}, node, {\n\t            children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))\n\t        });\n\t\n\t        return {\n\t            node: _nextNode2,\n\t            nextIndex: _childIndex,\n\t            insertedTreeIndex: _insertedTreeIndex,\n\t            parentPath: selfPath(_nextNode2)\n\t        };\n\t    }\n\t\n\t    // Skip over nodes with no children or hidden children\n\t    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return { node: node, nextIndex: currentIndex + 1 };\n\t    }\n\t\n\t    // Get all descendants\n\t    var insertedTreeIndex = null;\n\t    var pathFragment = null;\n\t    var childIndex = currentIndex + 1;\n\t    var newChildren = node.children;\n\t    if (typeof newChildren !== 'function') {\n\t        newChildren = newChildren.map(function (child, i) {\n\t            if (insertedTreeIndex !== null) {\n\t                return child;\n\t            }\n\t\n\t            var mapResult = addNodeAtDepthAndIndex({\n\t                targetDepth: targetDepth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                newNode: newNode,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                expandParent: expandParent,\n\t                isLastChild: isLastChild && i === newChildren.length - 1,\n\t                node: child,\n\t                currentIndex: childIndex,\n\t                currentDepth: currentDepth + 1,\n\t                getNodeKey: getNodeKey,\n\t                path: [] });\n\t\n\t            if ('insertedTreeIndex' in mapResult) {\n\t                insertedTreeIndex = mapResult.insertedTreeIndex;\n\t                pathFragment = mapResult.parentPath;\n\t            }\n\t\n\t            childIndex = mapResult.nextIndex;\n\t\n\t            return mapResult.node;\n\t        });\n\t    }\n\t\n\t    var nextNode = _extends({}, node, { children: newChildren });\n\t    var result = {\n\t        node: nextNode,\n\t        nextIndex: childIndex\n\t    };\n\t\n\t    if (insertedTreeIndex !== null) {\n\t        result.insertedTreeIndex = insertedTreeIndex;\n\t        result.parentPath = [].concat(_toConsumableArray(selfPath(nextNode)), _toConsumableArray(pathFragment));\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t/**\n\t * Insert a node into the tree at the given depth, after the minimum index\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!number} depth - The depth to insert the node at\n\t * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n\t * @param {!Object} newNode - The node to insert into the tree\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t *\n\t\n\t * @return {Object} result\n\t * @return {Object[]} result.treeData - The tree data with the node added\n\t * @return {number} result.treeIndex - The tree index at which the node was inserted\n\t * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n\t */\n\tfunction insertNode(_ref20) {\n\t    var treeData = _ref20.treeData,\n\t        targetDepth = _ref20.depth,\n\t        minimumTreeIndex = _ref20.minimumTreeIndex,\n\t        newNode = _ref20.newNode,\n\t        _ref20$getNodeKey = _ref20.getNodeKey,\n\t        getNodeKey = _ref20$getNodeKey === undefined ? function () {} : _ref20$getNodeKey,\n\t        _ref20$ignoreCollapse = _ref20.ignoreCollapsed,\n\t        ignoreCollapsed = _ref20$ignoreCollapse === undefined ? true : _ref20$ignoreCollapse,\n\t        _ref20$expandParent = _ref20.expandParent,\n\t        expandParent = _ref20$expandParent === undefined ? false : _ref20$expandParent;\n\t\n\t    if (!treeData && targetDepth === 0) {\n\t        return {\n\t            treeData: [newNode],\n\t            treeIndex: 0,\n\t            path: [getNodeKey({ node: newNode, treeIndex: 0 })]\n\t        };\n\t    }\n\t\n\t    var insertResult = addNodeAtDepthAndIndex({\n\t        targetDepth: targetDepth,\n\t        minimumTreeIndex: minimumTreeIndex,\n\t        newNode: newNode,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        expandParent: expandParent,\n\t        getNodeKey: getNodeKey,\n\t        isPseudoRoot: true,\n\t        isLastChild: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        currentDepth: -1\n\t    });\n\t\n\t    if (!('insertedTreeIndex' in insertResult)) {\n\t        throw new Error('No suitable position found to insert.');\n\t    }\n\t\n\t    var treeIndex = insertResult.insertedTreeIndex;\n\t    return {\n\t        treeData: insertResult.node.children,\n\t        treeIndex: treeIndex,\n\t        path: [].concat(_toConsumableArray(insertResult.parentPath), [getNodeKey({ node: newNode, treeIndex: treeIndex })])\n\t    };\n\t}\n\t\n\t/**\n\t * Get tree data flattened.\n\t *\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n\t *\n\t * @return {{\n\t *      node: Object,\n\t *      path: []string|[]number,\n\t *      lowerSiblingCounts: []number\n\t *  }}[] nodes - The node array\n\t */\n\tfunction getFlatDataFromTree(_ref21) {\n\t    var treeData = _ref21.treeData,\n\t        getNodeKey = _ref21.getNodeKey,\n\t        _ref21$ignoreCollapse = _ref21.ignoreCollapsed,\n\t        ignoreCollapsed = _ref21$ignoreCollapse === undefined ? true : _ref21$ignoreCollapse;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return [];\n\t    }\n\t\n\t    var flattened = [];\n\t    walk({\n\t        treeData: treeData,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        callback: function callback(_ref22) {\n\t            var node = _ref22.node,\n\t                lowerSiblingCounts = _ref22.lowerSiblingCounts,\n\t                path = _ref22.path,\n\t                treeIndex = _ref22.treeIndex;\n\t\n\t            flattened.push({ node: node, lowerSiblingCounts: lowerSiblingCounts, path: path, treeIndex: treeIndex });\n\t        }\n\t    });\n\t\n\t    return flattened;\n\t}\n\t\n\t/**\n\t * Generate a tree structure from flat data.\n\t *\n\t * @param {!Object[]} flatData\n\t * @param {!function=} getKey - Function to get the key from the nodeData\n\t * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n\t * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n\t *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n\t *\n\t * @return {Object[]} treeData - The flat data represented as a tree\n\t */\n\tfunction getTreeFromFlatData(_ref23) {\n\t    var flatData = _ref23.flatData,\n\t        _ref23$getKey = _ref23.getKey,\n\t        getKey = _ref23$getKey === undefined ? function (node) {\n\t        return node.id;\n\t    } : _ref23$getKey,\n\t        _ref23$getParentKey = _ref23.getParentKey,\n\t        getParentKey = _ref23$getParentKey === undefined ? function (node) {\n\t        return node.parentId;\n\t    } : _ref23$getParentKey,\n\t        _ref23$rootKey = _ref23.rootKey,\n\t        rootKey = _ref23$rootKey === undefined ? '0' : _ref23$rootKey;\n\t\n\t    if (!flatData) {\n\t        return [];\n\t    }\n\t\n\t    var childrenToParents = {};\n\t    flatData.forEach(function (child) {\n\t        var parentKey = getParentKey(child);\n\t\n\t        if (parentKey in childrenToParents) {\n\t            childrenToParents[parentKey].push(child);\n\t        } else {\n\t            childrenToParents[parentKey] = [child];\n\t        }\n\t    });\n\t\n\t    if (!(rootKey in childrenToParents)) {\n\t        return [];\n\t    }\n\t\n\t    var trav = function trav(parent) {\n\t        var parentKey = getKey(parent);\n\t        if (parentKey in childrenToParents) {\n\t            return _extends({}, parent, {\n\t                children: childrenToParents[parentKey].map(function (child) {\n\t                    return trav(child);\n\t                })\n\t            });\n\t        }\n\t\n\t        return _extends({}, parent);\n\t    };\n\t\n\t    return childrenToParents[rootKey].map(function (child) {\n\t        return trav(child);\n\t    });\n\t}\n\t\n\t/**\n\t * Check if a node is a descendant of another node.\n\t *\n\t * @param {!Object} older - Potential ancestor of younger node\n\t * @param {!Object} younger - Potential descendant of older node\n\t *\n\t * @return {boolean}\n\t */\n\tfunction isDescendant(older, younger) {\n\t    return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n\t        return child === younger || isDescendant(child, younger);\n\t    });\n\t}\n\t\n\t/**\n\t * Get the maximum depth of the children (the depth of the root node is 0).\n\t *\n\t * @param {!Object} node - Node in the tree\n\t * @param {?number} depth - The current depth\n\t *\n\t * @return {number} maxDepth - The deepest depth in the tree\n\t */\n\tfunction getDepth(node) {\n\t    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t    if (!node.children) {\n\t        return depth;\n\t    }\n\t\n\t    if (typeof node.children === 'function') {\n\t        return depth + 1;\n\t    }\n\t\n\t    return node.children.reduce(function (deepest, child) {\n\t        return Math.max(deepest, getDepth(child, depth + 1));\n\t    }, depth);\n\t}\n\t\n\t/**\n\t * Find nodes matching a search query in the tree,\n\t *\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n\t * @param {!Object[]} treeData - Tree data\n\t * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n\t * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n\t * @param {?number} searchFocusOffset - The offset of the match to focus on\n\t *                                      (e.g., 0 focuses on the first match, 1 on the second)\n\t * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n\t * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n\t *\n\t * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n\t * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n\t *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n\t *                               it will be the same as the original tree data.\n\t */\n\tfunction find(_ref24) {\n\t    var getNodeKey = _ref24.getNodeKey,\n\t        treeData = _ref24.treeData,\n\t        searchQuery = _ref24.searchQuery,\n\t        searchMethod = _ref24.searchMethod,\n\t        searchFocusOffset = _ref24.searchFocusOffset,\n\t        _ref24$expandAllMatch = _ref24.expandAllMatchPaths,\n\t        expandAllMatchPaths = _ref24$expandAllMatch === undefined ? false : _ref24$expandAllMatch,\n\t        _ref24$expandFocusMat = _ref24.expandFocusMatchPaths,\n\t        expandFocusMatchPaths = _ref24$expandFocusMat === undefined ? true : _ref24$expandFocusMat;\n\t\n\t    var matchCount = 0;\n\t    var trav = function trav(_ref25) {\n\t        var _ref25$isPseudoRoot = _ref25.isPseudoRoot,\n\t            isPseudoRoot = _ref25$isPseudoRoot === undefined ? false : _ref25$isPseudoRoot,\n\t            node = _ref25.node,\n\t            currentIndex = _ref25.currentIndex,\n\t            _ref25$path = _ref25.path,\n\t            path = _ref25$path === undefined ? [] : _ref25$path;\n\t\n\t        var matches = [];\n\t        var isSelfMatch = false;\n\t        var hasFocusMatch = false;\n\t        // The pseudo-root is not considered in the path\n\t        var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]);\n\t        var extraInfo = isPseudoRoot ? null : {\n\t            path: selfPath,\n\t            treeIndex: currentIndex\n\t        };\n\t\n\t        // Nodes with with children that aren't lazy\n\t        var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0;\n\t\n\t        // Examine the current node to see if it is a match\n\t        if (!isPseudoRoot && searchMethod(_extends({}, extraInfo, { node: node, searchQuery: searchQuery }))) {\n\t            if (matchCount === searchFocusOffset) {\n\t                hasFocusMatch = true;\n\t            }\n\t\n\t            // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n\t            //  is reached\n\t            matchCount++;\n\t\n\t            // We cannot add this node to the matches right away, as it may be changed\n\t            //  during the search of the descendants. The entire node is used in\n\t            //  comparisons between nodes inside the `matches` and `treeData` results\n\t            //  of this method (`find`)\n\t            isSelfMatch = true;\n\t        }\n\t\n\t        var childIndex = currentIndex;\n\t        var newNode = _extends({}, node);\n\t        if (hasChildren) {\n\t            // Get all descendants\n\t            newNode.children = newNode.children.map(function (child) {\n\t                var mapResult = trav({\n\t                    node: child,\n\t                    currentIndex: childIndex + 1,\n\t                    path: selfPath\n\t                });\n\t\n\t                // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n\t                // if the child is expanded.\n\t                //\n\t                // The child could have been expanded from the start,\n\t                // or expanded due to a matching node being found in its descendants\n\t                if (mapResult.node.expanded) {\n\t                    childIndex = mapResult.treeIndex;\n\t                } else {\n\t                    childIndex += 1;\n\t                }\n\t\n\t                if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n\t                    matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));\n\t                    if (mapResult.hasFocusMatch) {\n\t                        hasFocusMatch = true;\n\t                    }\n\t\n\t                    // Expand the current node if it has descendants matching the search\n\t                    // and the settings are set to do so.\n\t                    if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n\t                        newNode.expanded = true;\n\t                    }\n\t                }\n\t\n\t                return mapResult.node;\n\t            });\n\t        }\n\t\n\t        // Cannot assign a treeIndex to hidden nodes\n\t        if (!isPseudoRoot && !newNode.expanded) {\n\t            matches = matches.map(function (match) {\n\t                return _extends({}, match, {\n\t                    treeIndex: null\n\t                });\n\t            });\n\t        }\n\t\n\t        // Add this node to the matches if it fits the search criteria.\n\t        // This is performed at the last minute so newNode can be sent in its final form.\n\t        if (isSelfMatch) {\n\t            matches = [_extends({}, extraInfo, { node: newNode })].concat(_toConsumableArray(matches));\n\t        }\n\t\n\t        return {\n\t            node: matches.length > 0 ? newNode : node,\n\t            matches: matches,\n\t            hasFocusMatch: hasFocusMatch,\n\t            treeIndex: childIndex\n\t        };\n\t    };\n\t\n\t    var result = trav({\n\t        node: { children: treeData },\n\t        isPseudoRoot: true,\n\t        currentIndex: -1\n\t    });\n\t\n\t    return {\n\t        matches: result.matches,\n\t        treeData: result.node.children\n\t    };\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-sortable-tree.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9ae6ba7af62d54afff81","/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    node,\n    currentIndex,\n    getNodeKey,\n    path = [],\n    lowerSiblingCounts = [],\n    ignoreCollapsed = true,\n    isPseudoRoot = false,\n}) {\n    // The pseudo-root is not considered in the path\n    const selfPath = !isPseudoRoot ? [...path, getNodeKey({ node, treeIndex: currentIndex })] : [];\n\n    // Return target node when found\n    if (currentIndex === targetIndex) {\n        return {\n            node,\n            lowerSiblingCounts,\n            path: selfPath,\n        };\n    }\n\n    // Add one and continue for nodes with no children or hidden children\n    if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n        return { nextIndex: currentIndex + 1 };\n    }\n\n    // Iterate over each child and their descendants and return the\n    // target node if childIndex reaches the targetIndex\n    let childIndex   = currentIndex + 1;\n    const childCount = node.children.length;\n    for (let i = 0; i < childCount; i++) {\n        const result = getNodeDataAtTreeIndexOrNextIndex({\n            ignoreCollapsed,\n            getNodeKey,\n            targetIndex,\n            node: node.children[i],\n            currentIndex: childIndex,\n            lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\n            path: selfPath,\n        });\n\n        if (result.node) {\n            return result;\n        }\n\n        childIndex = result.nextIndex;\n    }\n\n    // If the target node is not found, return the farthest traversed index\n    return { nextIndex: childIndex };\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n    return getNodeDataAtTreeIndexOrNextIndex({\n        getNodeKey: () => {},\n        ignoreCollapsed,\n        node,\n        currentIndex: 0,\n        targetIndex:  -1,\n    }).nextIndex - 1;\n}\n\n/**\n * Walk all descendants of the given node\n */\nfunction walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot = false,\n    node,\n    currentIndex,\n    path = [],\n    lowerSiblingCounts = [],\n}) {\n    // The pseudo-root is not considered in the path\n    const selfPath = !isPseudoRoot ? [ ...path, getNodeKey({ node, treeIndex: currentIndex }) ] : [];\n    const selfInfo = !isPseudoRoot ? { node, path: selfPath, lowerSiblingCounts, treeIndex: currentIndex } : null;\n    if (!isPseudoRoot) {\n        const callbackResult = callback(selfInfo);\n\n        // Cut walk short if the callback returned false\n        if (callbackResult === false) {\n            return false;\n        }\n    }\n\n    // Return self on nodes with no children or hidden children\n    if (!node.children || (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)) {\n        return currentIndex;\n    }\n\n    // Get all descendants\n    let childIndex   = currentIndex;\n    const childCount = node.children.length;\n    if (typeof node.children !== 'function') {\n        for (let i = 0; i < childCount; i++) {\n            childIndex = walkDescendants({\n                callback,\n                getNodeKey,\n                ignoreCollapsed,\n                node: node.children[i],\n                currentIndex: childIndex + 1,\n                lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\n                path: selfPath,\n            });\n\n            // Cut walk short if the callback returned false\n            if (childIndex === false) {\n                return false;\n            }\n        }\n    }\n\n    return childIndex;\n}\n\n/**\n * Perform a change on the given node and all its descendants\n */\nfunction mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot = false,\n    node,\n    currentIndex,\n    path = [],\n    lowerSiblingCounts = [],\n}) {\n    // The pseudo-root is not considered in the path\n    const selfPath = !isPseudoRoot ? [ ...path, getNodeKey({ node, treeIndex: currentIndex }) ] : [];\n    const selfInfo = !isPseudoRoot ? { node, path: selfPath, lowerSiblingCounts, treeIndex: currentIndex } : null;\n\n    // Return self on nodes with no children or hidden children\n    if (!node.children || (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)) {\n        return {\n            treeIndex: currentIndex,\n            node: callback(selfInfo),\n        };\n    }\n\n    // Get all descendants\n    let childIndex   = currentIndex;\n    const childCount = node.children.length;\n    let newChildren  = node.children;\n    if (typeof newChildren !== 'function') {\n        newChildren = newChildren.map((child, i) => {\n            const mapResult = mapDescendants({\n                callback,\n                getNodeKey,\n                ignoreCollapsed,\n                node: child,\n                currentIndex: childIndex + 1,\n                lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\n                path: selfPath,\n            });\n            childIndex = mapResult.treeIndex;\n\n            return mapResult.node;\n        });\n    }\n\n    return {\n        node: callback({\n            ...selfInfo,\n            node: {\n                ...node,\n                children: newChildren,\n            },\n        }),\n        treeIndex: childIndex,\n    };\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n    const traverse = (node) => {\n        if (!node.children || node.expanded !== true || (typeof node.children === 'function')) {\n            return 1;\n        }\n\n        return 1 + node.children.reduce((total, currentNode) => (total + traverse(currentNode)), 0);\n    };\n\n    return treeData.reduce((total, currentNode) => total + traverse(currentNode), 0);\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({ treeData, index: targetIndex, getNodeKey }) {\n    if (!treeData || treeData.length < 1) {\n        return null;\n    }\n\n    // Call the tree traversal with a pseudo-root node\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n        targetIndex,\n        getNodeKey,\n        node: {\n            children: treeData,\n            expanded: true,\n        },\n        currentIndex: -1,\n        path: [],\n        lowerSiblingCounts: [],\n        isPseudoRoot: true,\n    });\n\n    if (result.node) {\n        return result;\n    }\n\n    return null;\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({ treeData, getNodeKey, callback, ignoreCollapsed = true }) {\n    if (!treeData || treeData.length < 1) {\n        return;\n    }\n\n    return walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        isPseudoRoot: true,\n        node: { children: treeData },\n        currentIndex: -1,\n        path: [],\n        lowerSiblingCounts: [],\n    });\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({ treeData, getNodeKey, callback, ignoreCollapsed = true }) {\n    if (!treeData || treeData.length < 1) {\n        return [];\n    }\n\n    return mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        isPseudoRoot: true,\n        node: { children: treeData },\n        currentIndex: -1,\n        path: [],\n        lowerSiblingCounts: [],\n    }).node.children;\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n    return map({\n        treeData,\n        callback: ({ node }) => ({ ...node, expanded }),\n        getNodeKey: ({ treeIndex }) => treeIndex,\n        ignoreCollapsed: false,\n    });\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({ treeData, path, newNode, getNodeKey, ignoreCollapsed = true }) {\n    const RESULT_MISS = 'RESULT_MISS';\n    const traverse = ({\n        isPseudoRoot = false,\n        node,\n        currentTreeIndex,\n        pathIndex,\n    }) => {\n        if (!isPseudoRoot && getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]) {\n            return RESULT_MISS;\n        }\n\n        if (pathIndex >= path.length - 1) {\n            // If this is the final location in the path, return its changed form\n            return typeof newNode === 'function' ? newNode({ node, treeIndex: currentTreeIndex }) : newNode;\n        } else if (!node.children) {\n            // If this node is part of the path, but has no children, return the unchanged node\n            throw new Error('Path referenced children of node with no children.');\n        }\n\n        let nextTreeIndex = currentTreeIndex + 1;\n        for (let i = 0; i < node.children.length; i++) {\n            const result = traverse({\n                node:             node.children[i],\n                currentTreeIndex: nextTreeIndex,\n                pathIndex:        pathIndex + 1,\n            });\n\n            // If the result went down the correct path\n            if (result !== RESULT_MISS) {\n                if (result) {\n                    // If the result was truthy (in this case, an object),\n                    //  pass it to the next level of recursion up\n                    return {\n                        ...node,\n                        children: [\n                            ...node.children.slice(0, i),\n                            result,\n                            ...node.children.slice(i + 1),\n                        ],\n                    };\n                }\n                // If the result was falsy (returned from the newNode function), then\n                //  delete the node from the array.\n                return {\n                    ...node,\n                    children: [\n                        ...node.children.slice(0, i),\n                        ...node.children.slice(i + 1),\n                    ],\n                };\n            }\n\n            nextTreeIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n        }\n\n        return RESULT_MISS;\n    };\n\n    // Use a pseudo-root node in the beginning traversal\n    const result = traverse({\n        node: { children: treeData },\n        currentTreeIndex: -1,\n        pathIndex: -1,\n        isPseudoRoot: true,\n    });\n\n    if (result === RESULT_MISS) {\n        throw new Error('No node found at the given path.');\n    }\n\n    return result.children;\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({ treeData, path, getNodeKey, ignoreCollapsed = true }) {\n    return changeNodeAtPath({\n        treeData,\n        path,\n        getNodeKey,\n        ignoreCollapsed,\n        newNode: null, // Delete the node\n    });\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({ treeData, path, getNodeKey, ignoreCollapsed = true }) {\n    let foundNodeInfo = null;\n\n    try {\n        changeNodeAtPath({\n            treeData,\n            path,\n            getNodeKey,\n            ignoreCollapsed,\n            newNode: ({ node, treeIndex }) => {\n                foundNodeInfo = { node, treeIndex };\n                return node;\n            },\n        });\n    } catch (err) {\n        // Ignore the error -- the null return will be explanation enough\n    }\n\n    return foundNodeInfo;\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n    treeData,\n    newNode,\n    parentKey = null,\n    getNodeKey,\n    ignoreCollapsed = true,\n    expandParent = false,\n}) {\n    if (parentKey === null) {\n        return {\n            treeData: [ ...(treeData || []), newNode],\n            treeIndex: (treeData || []).length,\n        };\n    }\n\n    let insertedTreeIndex = null;\n    let hasBeenAdded = false;\n    const changedTreeData = map({\n        treeData,\n        getNodeKey,\n        ignoreCollapsed,\n        callback: ({ node, treeIndex, path }) => {\n            const key = path ? path[path.length - 1] : null;\n            // Return nodes that are not the parent as-is\n            if (hasBeenAdded || key !== parentKey) {\n                return node;\n            }\n            hasBeenAdded = true;\n\n            const parentNode = {\n                ...node,\n            };\n\n            if (expandParent) {\n                parentNode.expanded = true;\n            }\n\n            // If no children exist yet, just add the single newNode\n            if (!parentNode.children) {\n                insertedTreeIndex = treeIndex + 1;\n                return {\n                    ...parentNode,\n                    children: [ newNode ],\n                };\n            }\n\n            if (typeof parentNode.children === 'function') {\n                throw new Error('Cannot add to children defined by a function');\n            }\n\n            let nextTreeIndex = treeIndex + 1;\n            for (let i = 0; i < parentNode.children.length; i++) {\n                nextTreeIndex += 1 + getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\n            }\n\n            insertedTreeIndex = nextTreeIndex;\n\n            return {\n                ...parentNode,\n                children: [ ...parentNode.children, newNode ],\n            };\n        },\n    });\n\n    if (!hasBeenAdded) {\n        throw new Error('No node found with the given key.');\n    }\n\n    return {\n        treeData: changedTreeData,\n        treeIndex: insertedTreeIndex,\n    };\n}\n\nfunction addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    isPseudoRoot = false,\n    isLastChild,\n    node,\n    currentIndex,\n    currentDepth,\n    getNodeKey,\n    path = [],\n}) {\n    const selfPath = n => (isPseudoRoot ? [] : [\n        ...path,\n        getNodeKey({ node: n, treeIndex: currentIndex }),\n    ]);\n\n    // If the potential parent node is at the targetDepth, it isn't eligible\n    if (currentDepth === targetDepth) {\n        return {\n            node,\n            nextIndex: currentIndex + 1 + getDescendantCount({ node, ignoreCollapsed }),\n        };\n    }\n\n    // If the current position is the only possible place to add, add it\n    if (currentIndex >= minimumTreeIndex - 1 || (isLastChild && !node.children)) {\n        if (typeof node.children === 'function') {\n            throw new Error('Cannot add to children defined by a function');\n        } else {\n            const extraNodeProps = expandParent ? { expanded: true } : {};\n            const nextNode = {\n                ...node,\n\n                ...extraNodeProps,\n                children: node.children ? [newNode, ...node.children] : [newNode],\n            };\n\n            return {\n                node: nextNode,\n                nextIndex: currentIndex + 2,\n                insertedTreeIndex: currentIndex + 1,\n                parentPath: selfPath(nextNode),\n            };\n        }\n    }\n\n    if (currentDepth === targetDepth - 1) {\n        // Skip over nodes with no children or hidden children\n        if (!node.children ||\n            typeof node.children === 'function' ||\n            (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n        ) {\n            return { node, nextIndex: currentIndex + 1 };\n        }\n\n        let childIndex        = currentIndex + 1;\n        let insertedTreeIndex = null;\n        let insertIndex       = null;\n        for (let i = 0; i < node.children.length; i++) {\n            if (childIndex >= minimumTreeIndex) {\n                insertedTreeIndex = childIndex;\n                insertIndex = i;\n                break;\n            }\n\n            childIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\n        }\n\n        if (insertIndex === null) {\n            if (childIndex < minimumTreeIndex && !isLastChild) {\n                return { node, nextIndex: childIndex };\n            }\n\n            insertedTreeIndex = childIndex;\n            insertIndex = node.children.length;\n        }\n\n        const nextNode = {\n            ...node,\n            children: [\n                ...node.children.slice(0, insertIndex),\n                newNode,\n                ...node.children.slice(insertIndex),\n            ],\n        };\n\n        return {\n            node: nextNode,\n            nextIndex: childIndex,\n            insertedTreeIndex,\n            parentPath: selfPath(nextNode),\n        };\n    }\n\n    // Skip over nodes with no children or hidden children\n    if (!node.children ||\n        typeof node.children === 'function' ||\n        (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n        return { node, nextIndex: currentIndex + 1 };\n    }\n\n    // Get all descendants\n    let insertedTreeIndex = null;\n    let pathFragment      = null;\n    let childIndex        = currentIndex + 1;\n    let newChildren       = node.children;\n    if (typeof newChildren !== 'function') {\n        newChildren = newChildren.map((child, i) => {\n            if (insertedTreeIndex !== null) {\n                return child;\n            }\n\n            const mapResult = addNodeAtDepthAndIndex({\n                targetDepth,\n                minimumTreeIndex,\n                newNode,\n                ignoreCollapsed,\n                expandParent,\n                isLastChild: isLastChild && i === newChildren.length - 1,\n                node: child,\n                currentIndex: childIndex,\n                currentDepth: currentDepth + 1,\n                getNodeKey,\n                path: [], // Cannot determine the parent path until the children have been processed\n            });\n\n            if ('insertedTreeIndex' in mapResult) {\n                ({ insertedTreeIndex, parentPath: pathFragment } = mapResult);\n            }\n\n            childIndex = mapResult.nextIndex;\n\n            return mapResult.node;\n        });\n    }\n\n    const nextNode = { ...node, children: newChildren };\n    const result = {\n        node: nextNode,\n        nextIndex: childIndex,\n    };\n\n    if (insertedTreeIndex !== null) {\n        result.insertedTreeIndex = insertedTreeIndex;\n        result.parentPath        = [ ...selfPath(nextNode), ...pathFragment ];\n    }\n\n    return result;\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n */\nexport function insertNode({\n    treeData,\n    depth: targetDepth,\n    minimumTreeIndex,\n    newNode,\n    getNodeKey = () => {},\n    ignoreCollapsed = true,\n    expandParent = false,\n}) {\n    if (!treeData && targetDepth === 0) {\n        return {\n            treeData:  [newNode],\n            treeIndex: 0,\n            path:      [getNodeKey({ node: newNode, treeIndex: 0 })],\n        };\n    }\n\n    const insertResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        getNodeKey,\n        isPseudoRoot: true,\n        isLastChild: true,\n        node: { children: treeData },\n        currentIndex: -1,\n        currentDepth: -1,\n    });\n\n    if (!('insertedTreeIndex' in insertResult)) {\n        throw new Error('No suitable position found to insert.');\n    }\n\n    const treeIndex = insertResult.insertedTreeIndex;\n    return {\n        treeData: insertResult.node.children,\n        treeIndex,\n        path:     [ ...insertResult.parentPath, getNodeKey({ node: newNode, treeIndex }) ],\n    };\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({ treeData, getNodeKey, ignoreCollapsed = true }) {\n    if (!treeData || treeData.length < 1) {\n        return [];\n    }\n\n    const flattened = [];\n    walk({\n        treeData,\n        getNodeKey,\n        ignoreCollapsed,\n        callback: ({ node, lowerSiblingCounts, path, treeIndex }) => {\n            flattened.push({ node, lowerSiblingCounts, path, treeIndex });\n        },\n    });\n\n    return flattened;\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n    flatData,\n    getKey = (node => node.id),\n    getParentKey = (node => node.parentId),\n    rootKey = '0',\n}) {\n    if (!flatData) {\n        return [];\n    }\n\n    const childrenToParents = {};\n    flatData.forEach((child) => {\n        const parentKey = getParentKey(child);\n\n        if (parentKey in childrenToParents) {\n            childrenToParents[parentKey].push(child);\n        } else {\n            childrenToParents[parentKey] = [ child ];\n        }\n    });\n\n    if (!(rootKey in childrenToParents)) {\n        return [];\n    }\n\n    const trav = (parent) => {\n        const parentKey = getKey(parent);\n        if (parentKey in childrenToParents) {\n            return {\n                ...parent,\n                children: childrenToParents[parentKey].map(child => trav(child)),\n            };\n        }\n\n        return { ...parent };\n    };\n\n    return childrenToParents[rootKey].map(child => trav(child));\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n    return !!older.children && typeof older.children !== 'function' &&\n        older.children.some(child => (child === younger || isDescendant(child, younger)));\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n    if (!node.children) {\n        return depth;\n    }\n\n    if (typeof node.children === 'function') {\n        return depth + 1;\n    }\n\n    return node.children.reduce(\n        (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n        depth\n    );\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n    getNodeKey,\n    treeData,\n    searchQuery,\n    searchMethod,\n    searchFocusOffset,\n    expandAllMatchPaths = false,\n    expandFocusMatchPaths = true,\n}) {\n    let matchCount = 0;\n    const trav = ({\n        isPseudoRoot = false,\n        node,\n        currentIndex,\n        path = [],\n    }) => {\n        let matches = [];\n        let isSelfMatch = false;\n        let hasFocusMatch = false;\n        // The pseudo-root is not considered in the path\n        const selfPath = isPseudoRoot ? [] : [\n            ...path,\n            getNodeKey({ node, treeIndex: currentIndex }),\n        ];\n        const extraInfo = isPseudoRoot ? null : {\n            path: selfPath,\n            treeIndex: currentIndex,\n        };\n\n        // Nodes with with children that aren't lazy\n        const hasChildren = node.children &&\n            typeof node.children !== 'function' &&\n            node.children.length > 0;\n\n        // Examine the current node to see if it is a match\n        if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n            if (matchCount === searchFocusOffset) {\n                hasFocusMatch = true;\n            }\n\n            // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n            //  is reached\n            matchCount++;\n\n            // We cannot add this node to the matches right away, as it may be changed\n            //  during the search of the descendants. The entire node is used in\n            //  comparisons between nodes inside the `matches` and `treeData` results\n            //  of this method (`find`)\n            isSelfMatch = true;\n        }\n\n        let childIndex = currentIndex;\n        const newNode = { ...node };\n        if (hasChildren) {\n            // Get all descendants\n            newNode.children = newNode.children.map((child) => {\n                const mapResult = trav({\n                    node: child,\n                    currentIndex: childIndex + 1,\n                    path: selfPath,\n                });\n\n                // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n                // if the child is expanded.\n                //\n                // The child could have been expanded from the start,\n                // or expanded due to a matching node being found in its descendants\n                if (mapResult.node.expanded) {\n                    childIndex = mapResult.treeIndex;\n                } else {\n                    childIndex += 1;\n                }\n\n                if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n                    matches = [ ...matches, ...mapResult.matches ];\n                    if (mapResult.hasFocusMatch) {\n                        hasFocusMatch = true;\n                    }\n\n                    // Expand the current node if it has descendants matching the search\n                    // and the settings are set to do so.\n                    if ((expandAllMatchPaths && mapResult.matches.length > 0) ||\n                        ((expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch)\n                    ) {\n                        newNode.expanded = true;\n                    }\n                }\n\n                return mapResult.node;\n            });\n        }\n\n        // Cannot assign a treeIndex to hidden nodes\n        if (!isPseudoRoot && !newNode.expanded) {\n            matches = matches.map(match => ({\n                ...match,\n                treeIndex: null,\n            }));\n        }\n\n        // Add this node to the matches if it fits the search criteria.\n        // This is performed at the last minute so newNode can be sent in its final form.\n        if (isSelfMatch) {\n            matches = [\n                { ...extraInfo, node: newNode },\n                ...matches,\n            ];\n        }\n\n        return {\n            node: matches.length > 0 ? newNode : node,\n            matches,\n            hasFocusMatch,\n            treeIndex: childIndex,\n        };\n    };\n\n    const result = trav({\n        node: { children: treeData },\n        isPseudoRoot: true,\n        currentIndex: -1,\n    });\n\n    return {\n        matches: result.matches,\n        treeData: result.node.children,\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}